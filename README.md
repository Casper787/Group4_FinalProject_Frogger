# Group4_FinalProject_Frogger

Problem:

Write an interactive program for a card game called Frogger.

Objective:

Develop an interface system using techniques and design patterns seen in class through a problem with realistic constraints.

Introduction:

In this repository you will see an implementation of a popular retro game named "frogger". The game consists of a frog on a side of a setting (alley, highway, river, etc.), a goal on the opposite side, and obstacles standing in between these two. The goal of the game is to move the frog appropriately in order to get it on the other side without encountering any of the obstacles. The obstacles can be any range of things (typically vehicles in a highway setting or logs in a river setting) and they will be moving across the screen. The frog has to maneuver swiftly and accurately to avoid "dying". The implementation seen here is one programmed usign Python 3 and the module graphics.py as the heart of the program.  Graphics.py allows users to create GUI's and visual objects and manipulate them to create very useful things, in this case, a game. 

Algorithm description: 

We start by initiating a variable called level and initiate at 1 (level = 1). After doing so we call our main with level as its one and only parameter.  The reasoning behind this will be clearer soon.  In our main() we initialize our game window called "Frogger" and make it 1000x1000 and with a black background.  After doing so we call screenSetup(win) to illustrate the lanes of our frogger game. We send win as the parameter so that the objects can be drawn succesfully on our game window. screenSetup(win) will draw 5 white vertical lines, with 10 pixels of thickness and 90 pixels in between each line. The closest to the right line will be colored lime to represent the goal, the finishline.  After the lane lines have been drawn, each vehicle will now be drawn. These vehicles are initialized as image objects, meaning we import image files into the program.  We have 4 total vehicles, a truck, a red car, a blue car, and a pink car. We have a function for each vehicle [Truck(win), Car(win), PinkCar(win), BlueCar(win)], each function has win as a parameter so that they are able to draw the vehicles on screen, they also return the vehicle. We store the return in a variable with the name of the appropriate vehicle for easier management throughout the program. The final call in our main(level) is misterFrog(truck, car, blueCar, pinkCar, win, level). This function draws our frog in the center of our screen ready to hop into the lanes. The frog object is also an image object and is 100x100. The reason misterFrog(truck, car, blueCar, pinkCar, win, level) carries all these parameters, after drawing the frog, we make a call to game_loop(froggo, truck, car, blueCar, pinkCar, win, level). This function is what makes the game go and here is where we start seeing structures and real algorithms. 

game_loop(froggo, truck, car, blueCar, pinkCar, win, level) - this function starts with a while True statement which will keep our loop running for the remainder of our playtime. Inside this loop we acquire the frog's center point by calling froggo.getAnchor() and store that Point value in froggo_center.  Upon doing so we make a call to frogMover(froggo, win). 

frogMover(froggo, win) - frogMover is the function in charge of taking the user's input and translating it into in game movements.  Here we will use the checkKey() function from graphics which returns the last key pressed, for example, if user presses the "x" key, checkKey() returns 'x'. after storing checkKey() in a variable called mover, we start making an if-elif structure to check for every direction. If the key pressed is an arrow key, the return is 'Up'or 'Down' and so on. The comparison we use in our if-elif structure checks for every possible return from every arrow key on the keyboard. if any of these cases returns true, the frog will move 100 real pixels, in that direction, using Graphics coordination system, if the user input was up, the frog will move (0, -100) units. This function runs consecutively since it's inside the while True statement fromg game_loop(). 

game_loop(froggo, truck, car, blueCar, pinkCar, win, level) *continuation* - After calling frogMover(froggo, win) we start an if statement that checks that the frog is to the left of the finishline (has not reached the goal). If this if returns true we send call car_move(froggo, truck, car, blueCar, pinkCar).

car_move(froggo, truck, car, blueCar, pinkCar) - This functions is what keeps our vehicles (also known as obstacles) moving. This function uses a function from the module time. We used time.sleep(0.05) with the parameter being seconds. This allows us to pause what happens in the program for 0.05 seconds and then continues with the program. After the use of time.sleep(0.05), we take the center of every vehicle and the frog and store it in a variable for later use. To move each vehicle we use vehicle.move(0, Y * level). We are moving vehicles up and down the lane, therefore we can't have a number different than 0 in the X coordinate, and we move each a car a certain amount of units in the Y axis and multiply that by the current level in play. We do this so that we can increase the difficulty of the game if the user surpasses a level. Every iteration of the game will increase the cars speed therefore making it harder to not crash. After we move a vehicle we have an if statement that will verify if the the car is in frame or not. If the vehicle is out frame (meaning that it has moved so many times in one direction that it is no longer visible on screen), we will move the vehicle to the opposite side of the frame so that we have the car driving on screen again.  After a full run of movements we call collision(froggo, truck, car, blue_car, pink_car, win, level) that will check if the cars have hit the frog.

collision(froggo, truck, car, blue_car, pink_car, win, level) - This function takes in the frog, the leve, win, and all the vehicles as parameters. This is necessary because we will be checking every vehicle and comparing it to our frog position.  The algorithm here is, every element that moves, we will store their center point and store it in a variable.  After that we use an if statement that will check if there was an intersection between a car an any vehicle seperately. We do this by checking for an intersection with a function for each and every vehicle. 

truck_hit(froggo, truck), car_hit(froggo, car), pinkCar_hit(froggo, pinkCar), blueCar_hit(froggo, blueCar) - All these functions will compare the locations of the frog and the vehicle, if in fact, there is overlapping between any of them, the function will return True. 

collision(froggo, truck, car, blue_car, pink_car, win, level) *continuation* - If any of the functions do return True, we on and call win_or_lose('L', win, level). 

win_or_lose(cond, win, level) - This function will generate a screen after the user wins or loses, with the appropriate buttons for each situation. We need personalized buttons for each situations because if the user loses we ask if the user wants to try again or quit, however, if the user wins we ask them if they want to try the next level or stop playing. The cond parameter will store the information necessary for the program to know if the user lost or won, the cond variable will either hold 'L' (if it was called through collision()) or 'W' (if it was called through game_loop()). If cond holds 'L' the function will generate a window called "Game Over" with a message and the buttons mentioned previosly. After generating said screen we wait for the user to click one of the buttons, if he clicks the Quit button, all windows will close, if he clicks the Play Agian button, main(level) will be called.  If cond holds 'W' the function will generate a window called "GG" with a message and the buttons stated previosly for the win scenario. If the user clicks on the Play Again button, main(level + 1) will be called.  **Clarification** The only time win_or_lose is called with cond = 'W' is when the frog reaches the finish line and then it is called through game_loop() in the elif statement. 

